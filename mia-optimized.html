<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="description" content="Kleiner interaktiver Beziehungsantrag mit animierten Bildern">
  <meta name="color-scheme" content="light dark">
  <meta name="theme-color" content="#ffdceb" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#2a0f1e" media="(prefers-color-scheme: dark)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="format-detection" content="telephone=no">
  <meta property="og:title" content="Willst du meine Freundin sein?">
  <meta property="og:description" content="Eine besondere Frage an eine besondere Person ðŸ’•">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://pgxbkmrxms-commits.github.io/Mia-pages/mia-optimized.html">
  <meta property="og:image" content="https://pgxbkmrxms-commits.github.io/Mia-pages/images/giphy.gif">
  <meta property="og:image:width" content="250">
  <meta property="og:image:height" content="250">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Willst du meine Freundin sein?">
  <meta name="twitter:description" content="Eine besondere Frage an eine besondere Person ðŸ’•">
  <meta name="twitter:image" content="https://pgxbkmrxms-commits.github.io/Mia-pages/images/giphy.gif">
  <title>Willst du meine Freundin sein?</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg1: #ffd0e5;
      --bg2: #ffe8f2;
      --accent: #bd1e59;
      --yes: #16a34a;
      --no: #ef4444;
      --heart: rgba(189, 30, 89, 0.22);
      --card: #ffffff;
      --shadow: 0 20px 60px rgba(189, 30, 89, 0.18);
      --radius: 16px;
      --transition-fast: 0.15s;
      --transition-normal: 0.25s;
      --transition-slow: 0.6s;
      --easing: cubic-bezier(0.4, 0, 0.2, 1);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    }

    body {
      background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 36%, #fff 100%);
      background-size: 100% 140%;
      animation: gradientShift 14s ease-in-out infinite;
      color: #2b0f1b;
    }

    .gradient-background {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
    }

    .card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 24px 28px;
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      max-width: 520px;
      width: 100%;
      animation: popIn var(--transition-slow) var(--easing) both;
      transition: transform var(--transition-fast) var(--easing), box-shadow var(--transition-fast) var(--easing);
      contain: layout style paint;
      will-change: transform;
      position: relative;
      z-index: 1;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 24px 70px rgba(189, 30, 89, 0.22);
    }

    .hearts {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
      content-visibility: auto;
      contain-intrinsic-size: 100vw 100vh;
    }

    .heart {
      position: absolute;
      width: 14px;
      height: 14px;
      background: var(--heart);
      transform: rotate(45deg);
      animation: floatUp 12s linear infinite;
      opacity: 0.8;
      animation-play-state: running;
    }

    .hearts.paused .heart {
      animation-play-state: paused;
    }

    .heart::before,
    .heart::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      background: var(--heart);
      border-radius: 50%;
    }

    .heart::before {
      left: -7px;
    }

    .heart::after {
      top: -7px;
    }

    img {
      border-radius: 12px;
      height: auto;
      max-width: 100%;
      width: 250px;
      aspect-ratio: 1 / 1;
      object-fit: cover;
      display: block;
      transition: opacity var(--transition-normal) var(--easing);
      contain: layout style paint;
      content-visibility: auto;
    }

    h1 {
      font-size: clamp(1.6rem, 2.2vw, 2.2rem);
      color: var(--accent);
      margin: 8px 0 0;
      font-weight: 700;
      font-style: italic;
      text-align: center;
      letter-spacing: 0.2px;
    }

    .subtext {
      margin: 0;
      color: #8a3a56;
      font-size: 0.98rem;
      text-align: center;
    }

    .hint {
      margin: 0;
      color: #9b5a73;
      font-size: 0.82rem;
      text-align: center;
    }

    .buttons {
      display: flex;
      gap: 12px;
      padding-top: 8px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      padding-top: 6px;
    }

    .secret-input-wrap {
      width: 100%;
      margin-top: 4px;
      display: flex;
      justify-content: center;
    }

    .secret-input {
      width: min(220px, 100%);
      border: 1px solid rgba(189, 30, 89, 0.25);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 0.9rem;
      text-align: center;
      color: inherit;
      background: rgba(255, 255, 255, 0.8);
    }

    .secret-input:focus-visible {
      outline: 3px solid rgba(189, 30, 89, 0.35);
      outline-offset: 2px;
      border-color: rgba(189, 30, 89, 0.45);
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 12px 22px;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
      transition: transform var(--transition-fast) var(--easing), 
                  box-shadow var(--transition-fast) var(--easing),
                  width var(--transition-normal) var(--easing),
                  height var(--transition-normal) var(--easing),
                  font-size var(--transition-normal) var(--easing);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      touch-action: manipulation;
      will-change: transform;
    }

    #yesButton { min-width: 120px; min-height: 44px; }

    button:focus-visible {
      outline: 3px solid rgba(189, 30, 89, 0.5);
      outline-offset: 3px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12), 0 0 0 3px rgba(189, 30, 89, 0.2);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px) scale(1.02);
      animation: buttonPulse 1.5s ease-in-out infinite;
    }

    button:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
      animation: none;
    }

    @keyframes buttonPulse {
      0%, 100% { box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12); }
      50% { box-shadow: 0 12px 28px rgba(0, 0, 0, 0.18); }
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #yesButton {
      background: var(--yes);
    }

    #noButton {
      background: var(--no);
    }

    #maybeButton {
      background: #f59e0b;
    }

    #resetButton {
      background: #f472b6;
      font-size: 16px;
      padding: 10px 18px;
    }

    .bounce {
      animation: bounce 2s ease infinite;
    }

    @keyframes bounce {
      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-20px);
      }
      60% {
        transform: translateY(-10px);
      }
    }

    @keyframes popIn {
      0% { transform: translateY(10px) scale(0.98); opacity: 0; }
      100% { transform: translateY(0) scale(1); opacity: 1; }
    }

    @keyframes floatUp {
      0% { transform: translateY(20vh) rotate(45deg) scale(0.9); opacity: 0; }
      10% { opacity: 0.85; }
      100% { transform: translateY(-120vh) rotate(45deg) scale(1.1); opacity: 0; }
    }

    @keyframes shake {
      0% { transform: translate3d(0, 0, 0); }
      20% { transform: translate3d(-6px, 0, 0); }
      40% { transform: translate3d(6px, 0, 0); }
      60% { transform: translate3d(-4px, 0, 0); }
      80% { transform: translate3d(4px, 0, 0); }
      100% { transform: translate3d(0, 0, 0); }
    }

    .shake {
      animation: shake 0.3s ease;
    }

    .swipe-feedback {
      animation: pulse 0.3s ease;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    @keyframes gradientShift {
      0% { background-position: 50% 0%; }
      50% { background-position: 50% 100%; }
      100% { background-position: 50% 0%; }
    }

    @media (max-width: 420px) {
      .buttons {
        flex-direction: column;
        width: 100%;
      }

      button {
        width: 100%;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .bounce {
        animation: none;
      }

      .card {
        animation: none;
      }

      .secret-card {
        animation: none;
      }

      .heart {
        animation: none;
        opacity: 0.25;
      }

      button {
        transition: none;
      }

      body {
        animation: none;
      }
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg1: #2a0f1e;
        --bg2: #160a12;
        --accent: #ff7fb0;
        --heart: rgba(255, 127, 176, 0.35);
        --card: rgba(29, 18, 24, 0.95);
        --shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        --yes: #22c55e; --no: #f87171;
      }

      body {
        color: #f6dbe6;
      }

      .subtext {
        color: #d9a6ba;
      }

      .card {
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }

      .secret-input {
        background: rgba(29, 18, 24, 0.75);
        border-color: rgba(255, 127, 176, 0.35);
      }
    }

    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 1px, 1px); white-space: nowrap; border: 0; }

    .visually-hidden.is-visible {
      position: static;
      width: auto;
      height: auto;
      margin: 0;
      clip: auto;
      overflow: visible;
      white-space: normal;
      font-size: 0.9rem;
      font-weight: 600;
      text-align: center;
    }

    .secret-overlay {
      position: fixed;
      inset: 0;
      background: rgba(20, 10, 16, 0.55);
      display: grid;
      place-items: center;
      padding: 20px;
      z-index: 10;
    }

    .secret-overlay[hidden] {
      display: none !important;
    }

    .secret-card {
      background: var(--card);
      color: inherit;
      border-radius: 16px;
      padding: 20px;
      max-width: 420px;
      width: 100%;
      text-align: center;
      box-shadow: var(--shadow);
      animation: popIn var(--transition-slow) var(--easing) both;
    }

    .secret-card h2 {
      margin: 0 0 8px;
      color: var(--accent);
    }

    .secret-card p {
      margin: 0 0 14px;
    }

    .secret-close {
      background: #ec4899;
      padding: 10px 16px;
      font-size: 16px;
    }
  </style>
</head>
<body class="gradient-background">
  <div class="hearts" aria-hidden="true">
    <span class="heart" style="left: 8%; animation-delay: 0s;"></span>
    <span class="heart" style="left: 18%; animation-delay: 2s; animation-duration: 14s;"></span>
    <span class="heart" style="left: 32%; animation-delay: 4s; animation-duration: 12s;"></span>
    <span class="heart" style="left: 46%; animation-delay: 1s; animation-duration: 16s;"></span>
    <span class="heart" style="left: 58%; animation-delay: 3s; animation-duration: 13s;"></span>
    <span class="heart" style="left: 70%; animation-delay: 6s; animation-duration: 15s;"></span>
    <span class="heart" style="left: 82%; animation-delay: 5s; animation-duration: 11s;"></span>
    <span class="heart" style="left: 92%; animation-delay: 7s; animation-duration: 17s;"></span>
  </div>
  <main class="card" aria-labelledby="valentineQuestion" id="card">
    <div id="status" role="status" aria-live="polite" aria-atomic="true" class="visually-hidden"></div>
    <img id="imageDisplay" src="images/giphy.gif" alt="Niedliche animierte Grafik zum Valentinstag" width="250" height="250" loading="eager" decoding="async" fetchpriority="high" />
    <h1 id="valentineQuestion">Willst du meine Freundin sein?</h1>
    <p class="subtext" id="subtext">Ein kleines Ja macht meinen Tag perfekt.</p>
    <p class="hint" id="hint">Tipp: Mit Y/N/P geht's noch schneller. <span aria-hidden="true">Oder wische nach rechts/links! Geheimcode: unten einfach â€žmiaâ€œ eintippen.</span></p>
    <div class="buttons" id="responseButtons" role="group" aria-label="Antwortoptionen">
      <button id="yesButton" class="bounce" aria-label="Ja" type="button">Ja</button>
      <button id="maybeButton" aria-label="Vielleicht" type="button">Vielleicht</button>
      <button id="noButton" aria-label="Nein" type="button">Nein</button>
    </div>
    <div class="actions" id="afterActions" hidden>
      <button id="resetButton" type="button" aria-label="Von vorne beginnen">Nochmal ðŸ”„</button>
    </div>
    <div class="secret-input-wrap">
      <label for="secretInput" class="visually-hidden">Geheimen Code eingeben</label>
      <input id="secretInput" class="secret-input" type="text" inputmode="text" autocomplete="off" autocapitalize="none" spellcheck="false" maxlength="16" placeholder="geheimer codeâ€¦" aria-label="Geheimen Code eingeben" />
    </div>
  </main>
  <div id="secretOverlay" class="secret-overlay" hidden aria-hidden="true">
    <div class="secret-card" role="dialog" aria-modal="true" aria-labelledby="secretTitle" aria-describedby="secretText">
      <h2 id="secretTitle">Du hast das geheime Level gefunden ðŸ’–</h2>
      <p id="secretText">Du bist mein Lieblingsmensch. FÃ¼r immer und jeden Tag ein bisschen mehr.</p>
      <button id="secretCloseButton" class="secret-close" type="button" aria-label="Geheime Nachricht schlieÃŸen">Awww ðŸ¥°</button>
    </div>
  </div>
  <noscript>Bitte aktiviere JavaScript, damit die Interaktionen funktionieren.</noscript>

  <script>
    // Configuration constants
    const CONFIG = {
      BUTTON_GROW_WIDTH: 20,
      BUTTON_GROW_HEIGHT: 20,
      FONT_SIZE_INCREASE: 6,
      MAX_BUTTON_WIDTH_FACTOR: 0.8,
      MAX_BUTTON_HEIGHT: 200,
      MAX_FONT_SIZE: 40,
      CONFETTI_TIMEOUT: 5000,
      PRELOAD_TIMEOUT: 2000,
      PRELOAD_FALLBACK: 100,
      CONFETTI_DELAYS: [0, 250, 550],
      STORAGE_KEY: 'valentineState',
      HAPTIC_LIGHT: 10,
      HAPTIC_MEDIUM: 20,
      HAPTIC_HEAVY: 50,
      SWIPE_THRESHOLD: 50,
      STATE_MAX_AGE_MS: 3600000,
      STATUS_CLEAR_MS: 2800,
      SHAKE_RESET_DELAY_MS: 320,
      SECRET_CODE: 'mia'
    };

    // Haptic Feedback
    const hapticFeedback = (intensity = CONFIG.HAPTIC_LIGHT) => {
      if ('vibrate' in navigator) {
        navigator.vibrate(intensity);
      }
    };

    let audioContext = null;
    const getAudioContext = () => {
      if (audioContext) {
        return audioContext;
      }
      const AudioContextClass = window.AudioContext || window.webkitAudioContext;
      if (!AudioContextClass) {
        return null;
      }
      audioContext = new AudioContextClass();
      return audioContext;
    };

    const playCuteChime = () => {
      try {
        const ctx = getAudioContext();
        if (!ctx) return;
        if (ctx.state === 'suspended') {
          ctx.resume().catch(() => {});
        }
        const now = ctx.currentTime;
        const master = ctx.createGain();
        master.gain.setValueAtTime(0.0001, now);
        master.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
        master.gain.exponentialRampToValueAtTime(0.0001, now + 0.65);
        master.connect(ctx.destination);

        [523.25, 659.25, 783.99].forEach((freq, index) => {
          const start = now + index * 0.12;
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, start);
          gain.gain.setValueAtTime(0.0001, start);
          gain.gain.exponentialRampToValueAtTime(0.28, start + 0.03);
          gain.gain.exponentialRampToValueAtTime(0.0001, start + 0.26);
          osc.connect(gain);
          gain.connect(master);
          osc.start(start);
          osc.stop(start + 0.3);
        });
      } catch (e) {
        // ignore audio errors
      }
    };

    // Performance monitoring
    const logPerformance = () => {
      if ('performance' in window && 'getEntriesByType' in performance) {
        try {
          const perfData = performance.getEntriesByType('navigation')[0];
          if (perfData) {
            console.log('Load time:', Math.round(perfData.loadEventEnd - perfData.fetchStart), 'ms');
          }
        } catch (e) {
          // Ignore errors
        }
      }
    };

    // Connection-aware loading
    const shouldPreload = () => {
      if ('connection' in navigator) {
        const conn = navigator.connection;
        if (conn.saveData) return false;
        if (conn.effectiveType === 'slow-2g' || conn.effectiveType === '2g') return false;
      }
      return true;
    };

    // State management
    const saveState = () => {
      try {
        const state = { noClickCount, buttonWidth, buttonHeight, fontSize, timestamp: Date.now() };
        sessionStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Failed to save state:', e);
      }
    };

    const loadState = () => {
      try {
        const saved = sessionStorage.getItem(CONFIG.STORAGE_KEY);
        if (saved) {
          const state = JSON.parse(saved);
          const age = Date.now() - (state.timestamp || 0);
          if (age < CONFIG.STATE_MAX_AGE_MS) return state;
        }
      } catch (e) {
        console.warn('Failed to load state:', e);
      }
      return null;
    };

    const clearState = () => {
      try {
        sessionStorage.removeItem(CONFIG.STORAGE_KEY);
      } catch (e) {
        console.warn('Failed to clear state:', e);
      }
    };

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    const setStatus = (message, { isError = false, persist = false } = {}) => {
      if (!statusEl) {
        return;
      }
      statusEl.textContent = message;
      statusEl.classList.toggle('is-visible', !!message);
      statusEl.style.color = isError ? '#ef4444' : '';
      if (!persist && message) {
        setTimeout(() => {
          if (!statusEl) return;
          statusEl.textContent = '';
          statusEl.classList.remove('is-visible');
          statusEl.style.color = '';
        }, CONFIG.STATUS_CLEAR_MS);
      }
    };

    // Error boundary
    const showError = (message) => {
      setStatus(message, { isError: true });
    };

    window.addEventListener('error', (event) => {
      console.error('Global error:', event.error);
      showError('Ein Fehler ist aufgetreten. Bitte Seite neu laden.');
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
    });

    // Cleanup listeners array
    const listeners = [];
    const addListener = (element, event, handler, options) => {
      element.addEventListener(event, handler, options);
      listeners.push({ element, event, handler, options });
    };

    const cleanup = () => {
      listeners.forEach(({ element, event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
      listeners.length = 0;
      if (heartsObserver) {
        heartsObserver.disconnect();
        heartsObserver = null;
      }
    };

    const getById = (id) => document.getElementById(id);

    const imagePaths = [
      "images/giphy.gif",
      "images/image2.gif",
      "images/image3.gif",
      "images/image4.gif",
      "images/image5.gif",
      "images/image6.gif",
      "images/image7.gif"
    ];

    const imageAlts = [
      "Willst du meine Freundin sein ? Frage an die wichtigste Person in meinem Leben",
      "SÃ¼ÃŸe Reaktion 1",
      "SÃ¼ÃŸe Reaktion 2",
      "SÃ¼ÃŸe Reaktion 3",
      "SÃ¼ÃŸe Reaktion 4",
      "SÃ¼ÃŸe Reaktion 5",
      "SÃ¼ÃŸe Reaktion 6"
    ];

    const noTexts = [
      "Nein",
      "Bist du dir sicher?",
      "Ganz sicher?",
      "Wirklich ganz ganz sicher?:(",
      "Immernoch nicht?",
      "Warum nicht :("
    ];

    const maybeTexts = [
      "Vielleicht? Ich nehm's als sÃ¼ÃŸes Fast-Ja ðŸ’•",
      "Ich warte gern auf dein Ja ðŸ«¶",
      "Du bist jede Sekunde Warten wert âœ¨"
    ];

    const finalIndex = imagePaths.length - 1;
    const maxNoClicks = Math.min(noTexts.length - 1, finalIndex);
    let confettiLoading = null;
    let noClickCount = 0;
    let buttonWidth = 0;
    let buttonHeight = 0;
    let fontSize = 0;
    let didPreload = false;
    let didFallback = false;
    let statusEl = null;
    let heartsObserver = null;
    let maybeClickCount = 0;

    const setImage = (imageDisplay, src, alt) => {
      const currentSrc = imageDisplay.src.split('?')[0];
      const newSrc = src.includes('://') ? src.split('?')[0] : new URL(src, window.location.href).href.split('?')[0];
      
      if (currentSrc === newSrc) return;
      
      imageDisplay.style.opacity = "0";
      if (alt) {
        imageDisplay.alt = alt;
      }
      
      const onLoad = () => {
        requestAnimationFrame(() => {
          imageDisplay.style.opacity = "1";
        });
      };
      
      imageDisplay.addEventListener("load", onLoad, { once: true });
      imageDisplay.src = src;
      
      if (imageDisplay.complete && imageDisplay.naturalHeight !== 0) {
        onLoad();
      }
    };

    const updateYesButton = (yesButton) => {
      const maxSize = Math.min(window.innerWidth * CONFIG.MAX_BUTTON_WIDTH_FACTOR, 420);
      const clampedWidth = Math.min(buttonWidth, maxSize);
      const clampedHeight = Math.min(buttonHeight, CONFIG.MAX_BUTTON_HEIGHT);
      const clampedFont = Math.min(fontSize, CONFIG.MAX_FONT_SIZE);
      yesButton.style.width = `${clampedWidth}px`;
      yesButton.style.height = `${clampedHeight}px`;
      yesButton.style.fontSize = `${clampedFont}px`;
    };

    const loadConfetti = () => {
      if (typeof confetti === "function") {
        return Promise.resolve();
      }
      if (confettiLoading) {
        return confettiLoading;
      }
      confettiLoading = new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = "libs/confetti.min.js";
        script.defer = true;
        const timer = setTimeout(() => {
          console.warn("Confetti loading timeout");
          resolve();
        }, CONFIG.CONFETTI_TIMEOUT);
        script.onload = () => { 
          clearTimeout(timer); 
          resolve(); 
        };
        script.onerror = (e) => { 
          clearTimeout(timer); 
          console.error("Confetti loading failed:", e);
          resolve(); 
        };
        document.head.appendChild(script);
      });
      return confettiLoading;
    };

    const handleNo = (yesButton, noButton, imageDisplay, card) => {
      if (noClickCount >= maxNoClicks) {
        return;
      }
      hapticFeedback(CONFIG.HAPTIC_MEDIUM);
      noClickCount += 1;
      setImage(imageDisplay, imagePaths[noClickCount], imageAlts[noClickCount] || imageAlts[0]);
      if (card) {
        card.classList.remove("shake");
        requestAnimationFrame(() => {
          card.classList.add("shake");
          setTimeout(() => card.classList.remove("shake"), CONFIG.SHAKE_RESET_DELAY_MS);
        });
      }
      buttonWidth += CONFIG.BUTTON_GROW_WIDTH;
      buttonHeight += CONFIG.BUTTON_GROW_HEIGHT;
      fontSize += CONFIG.FONT_SIZE_INCREASE;
      updateYesButton(yesButton);
      noButton.textContent = noTexts[noClickCount];
      saveState();
      setStatus(`Du hast "${noButton.textContent}" gewÃ¤hlt.`);
      if (noClickCount >= maxNoClicks) {
        noButton.disabled = true;
        noButton.setAttribute("aria-disabled", "true");
        setStatus("Okay, ich frage nicht mehr.", { persist: true });
      }
      // Intelligentes Prefetch: Lade nÃ¤chstes Bild und finale Bild vor
      const nextIndex = Math.min(noClickCount + 1, finalIndex);
      if (nextIndex > noClickCount) {
        const img = new Image();
        img.src = imagePaths[nextIndex];
      }
      if (nextIndex !== finalIndex) {
        const finalImg = new Image();
        finalImg.src = imagePaths[finalIndex];
      }
      // Konfetti-Preload nach 2 Nein-Clicks
      if (noClickCount >= 2 && !confettiLoading) {
        loadConfetti().catch(() => {});
      }
    };

    const handleMaybe = (subtext, card) => {
      hapticFeedback(CONFIG.HAPTIC_LIGHT);
      playCuteChime();
      const text = maybeTexts[Math.min(maybeClickCount, maybeTexts.length - 1)];
      maybeClickCount += 1;
      if (subtext) {
        subtext.textContent = text;
      }
      setStatus(text);
      if (card) {
        card.classList.add('swipe-feedback');
        setTimeout(() => card.classList.remove('swipe-feedback'), 300);
      }
    };

    const handleYes = (valentineQuestion, responseButtons, imageDisplay, subtext, hint, afterActions) => {
      hapticFeedback(CONFIG.HAPTIC_HEAVY);
      playCuteChime();
      setImage(imageDisplay, imagePaths[finalIndex], "Jubelndes GIF â€“ Danke fÃ¼r dein Ja!");
      valentineQuestion.textContent = "Yayyy!! :3";
      valentineQuestion.setAttribute("tabindex", "-1");
      valentineQuestion.focus({ preventScroll: true });
      if (subtext) { subtext.textContent = "Du hast mir ein LÃ¤cheln geschenkt."; }
      if (hint) { hint.style.display = "none"; }
      setStatus("Danke fÃ¼r dein Ja!", { persist: true });
      responseButtons.style.display = "none";
      if (afterActions) { afterActions.hidden = false; }
      clearState();
      if (!window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
        loadConfetti().then(() => {
          if (typeof confetti === "function") {
            const fireConfetti = () => {
              confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
              });
            };
            CONFIG.CONFETTI_DELAYS.forEach((delay) => {
              setTimeout(fireConfetti, delay);
            });
          }
        }).catch((err) => {
          console.error("Confetti error:", err);
        });
      }
    };

    const handleSecretCodeInput = (value, openSecretOverlay) => {
      const normalized = String(value || '').toLowerCase().replace(/[^a-z]/g, '');
      if (normalized === CONFIG.SECRET_CODE) {
        openSecretOverlay();
        return true;
      }
      return false;
    };

    const preloadOnFirstInteraction = () => {
      if (didPreload || !shouldPreload()) {
        return;
      }
      didPreload = true;
      const loadImages = () => {
        for (let i = 1; i < imagePaths.length; i += 1) {
          const img = new Image();
          img.src = imagePaths[i];
        }
      };
      if ("requestIdleCallback" in window) {
        requestIdleCallback(loadImages, { timeout: CONFIG.PRELOAD_TIMEOUT });
      } else {
        setTimeout(loadImages, CONFIG.PRELOAD_FALLBACK);
      }
    };

    window.addEventListener("DOMContentLoaded", () => {
      const yesButton = getById("yesButton");
      const maybeButton = getById("maybeButton");
      const noButton = getById("noButton");
      const valentineQuestion = getById("valentineQuestion");
      const responseButtons = getById("responseButtons");
      const imageDisplay = getById("imageDisplay");
      const subtext = getById("subtext");
      const hint = getById("hint");
      const afterActions = getById("afterActions");
      const resetButton = getById("resetButton");
      const secretInput = getById('secretInput');
      const card = getById("card");
      const secretOverlay = getById('secretOverlay');
      const secretCloseButton = getById('secretCloseButton');
      statusEl = getById("status");

      if (!yesButton || !maybeButton || !noButton || !valentineQuestion || !responseButtons || !imageDisplay) {
        console.error("Required elements not found");
        return;
      }

      if (secretInput) {
        secretInput.value = '';
      }

      const openSecretOverlay = () => {
        if (!secretOverlay) return;
        secretOverlay.hidden = false;
        secretOverlay.setAttribute('aria-hidden', 'false');
        document.body.style.overflow = 'hidden';
        playCuteChime();
        setStatus('Geheime Nachricht freigeschaltet ðŸ’–', { persist: true });
        if (secretInput) {
          secretInput.value = '';
        }
        if (secretCloseButton) {
          secretCloseButton.focus({ preventScroll: true });
        }
      };

      const closeSecretOverlay = () => {
        if (!secretOverlay) return;
        secretOverlay.hidden = true;
        secretOverlay.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = '';
        yesButton.focus({ preventScroll: true });
      };

      // Load saved state
      const savedState = loadState();
      if (savedState) {
        noClickCount = clamp(Number(savedState.noClickCount) || 0, 0, maxNoClicks);
        buttonWidth = clamp(Number(savedState.buttonWidth) || yesButton.offsetWidth || 120, 120, 420);
        buttonHeight = clamp(Number(savedState.buttonHeight) || yesButton.offsetHeight || 44, 44, CONFIG.MAX_BUTTON_HEIGHT);
        fontSize = clamp(Number(savedState.fontSize) || parseFloat(getComputedStyle(yesButton).fontSize) || 20, 16, CONFIG.MAX_FONT_SIZE);
        if (noClickCount > 0) {
          setImage(imageDisplay, imagePaths[noClickCount], imageAlts[noClickCount]);
          updateYesButton(yesButton);
          noButton.textContent = noTexts[noClickCount];
          if (noClickCount >= maxNoClicks) {
            noButton.disabled = true;
            noButton.setAttribute("aria-disabled", "true");
          }
        }
      } else {
        buttonWidth = yesButton.offsetWidth || 120;
        buttonHeight = yesButton.offsetHeight || 44;
        fontSize = parseFloat(getComputedStyle(yesButton).fontSize) || 20;
      }
      imageDisplay.style.opacity = "1";

      // Intersection Observer for hearts animation
      const heartsContainer = document.querySelector('.hearts');
      if (heartsContainer && 'IntersectionObserver' in window && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        heartsObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            heartsContainer.classList.toggle('paused', !entry.isIntersecting);
          });
        }, { threshold: 0.1 });
        heartsObserver.observe(heartsContainer);
      }

      const firstNext = new Image();
      firstNext.src = imagePaths[1];

      imageDisplay.addEventListener("error", () => {
        if (didFallback) return;
        didFallback = true;
        setImage(imageDisplay, imagePaths[finalIndex], "Fallback-Bild");
      });

      addListener(noButton, "click", () => handleNo(yesButton, noButton, imageDisplay, card));
      addListener(maybeButton, "click", () => handleMaybe(subtext, card));
      addListener(yesButton, "click", () => handleYes(valentineQuestion, responseButtons, imageDisplay, subtext, hint, afterActions));
      if (secretCloseButton) {
        addListener(secretCloseButton, 'click', closeSecretOverlay);
      }
      if (secretOverlay) {
        addListener(secretOverlay, 'click', (event) => {
          if (event.target === secretOverlay) {
            closeSecretOverlay();
          }
        });
      }
      if (secretInput) {
        addListener(secretInput, 'keyup', (event) => {
          const inputEl = event.target;
          if (!inputEl || typeof inputEl.value !== 'string') return;
          if (handleSecretCodeInput(inputEl.value, openSecretOverlay)) {
            inputEl.value = '';
          }
        });
      }
      if (resetButton) {
        addListener(resetButton, "click", () => {
          clearState();
          cleanup();
          window.location.reload();
        });
      }
      const events = ["pointerdown", "touchstart", "mousedown"];
      events.forEach((eventType) => {
        addListener(document, eventType, preloadOnFirstInteraction, { once: true, passive: true });
      });
      
      let lastKeyTime = 0;
      const KEY_DEBOUNCE = 200;
      
      addListener(document, "keydown", (event) => {
        if (event.metaKey || event.ctrlKey || event.altKey) {
          return;
        }

        const key = event.key.toLowerCase();

        if (secretOverlay && !secretOverlay.hidden) {
          if (key === 'escape') {
            event.preventDefault();
            closeSecretOverlay();
          }
          return;
        }

        const target = event.target;
        const isTypingTarget = target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || (target && target.isContentEditable);
        if (isTypingTarget) {
          return;
        }

        if (responseButtons.style.display === "none") {
          return;
        }
        
        const now = Date.now();
        if (now - lastKeyTime < KEY_DEBOUNCE) {
          return;
        }
        
        if (key === "y" || key === "j") {
          event.preventDefault();
          lastKeyTime = now;
          yesButton.click();
        } else if (key === "p") {
          event.preventDefault();
          lastKeyTime = now;
          maybeButton.click();
        } else if (key === "n") {
          event.preventDefault();
          lastKeyTime = now;
          noButton.click();
        }
      }, { passive: false });

      // Page Visibility API - pause animations when tab is hidden
      addListener(document, 'visibilitychange', () => {
        const hearts = document.querySelector('.hearts');
        if (document.hidden && hearts) {
          hearts.classList.add('paused');
        } else if (hearts && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          hearts.classList.remove('paused');
        }
      });

      // Cleanup on page unload
      addListener(window, 'beforeunload', () => {
        cleanup();
      });

      addListener(window, 'resize', () => {
        updateYesButton(yesButton);
      }, { passive: true });

      // Touch gestures for mobile
      let touchStartX = 0;
      let touchStartY = 0;
      
      addListener(card, 'touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, { passive: true });
      
      addListener(card, 'touchend', (e) => {
        if (responseButtons.style.display === 'none') return;
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Swipe right for Yes, left for No
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > CONFIG.SWIPE_THRESHOLD) {
          hapticFeedback(CONFIG.HAPTIC_LIGHT);
          card.classList.add('swipe-feedback');
          setTimeout(() => card.classList.remove('swipe-feedback'), 300);
          
          if (deltaX > 0) {
            yesButton.click();
          } else {
            noButton.click();
          }
        }
      }, { passive: true });

      // Log performance metrics
      if (document.readyState === 'complete') {
        logPerformance();
      } else {
        addListener(window, 'load', logPerformance);
      }

      // Register Service Worker for offline functionality
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js', { scope: './' }).then(() => {
            console.log('Service Worker registered');
          }).catch(() => {
            console.log('Service Worker registration failed');
          });
        });
      }
    });
  </script>
</body>
</html>
