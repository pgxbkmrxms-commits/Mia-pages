<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="description" content="Kleiner interaktiver Beziehungsantrag mit animierten Bildern">
  <meta name="color-scheme" content="light dark">
  <meta name="theme-color" content="#ffdceb" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#2a0f1e" media="(prefers-color-scheme: dark)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="format-detection" content="telephone=no">
  <meta property="og:title" content="Willst du meine Freundin sein?">
  <meta property="og:description" content="Eine besondere Frage an eine besondere Person ðŸ’•">
  <meta property="og:type" content="website">
  <meta property="og:image" content="images/giphy.gif">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Willst du meine Freundin sein?">
  <meta name="twitter:description" content="Eine besondere Frage an eine besondere Person ðŸ’•">
  <title>Willst du meine Freundin sein?</title>
  <link rel="preload" as="image" href="images/giphy.gif" fetchpriority="high">
  <link rel="preconnect" href="libs/" crossorigin>
  <link rel="dns-prefetch" href="libs/">
  <style>
    :root {
      color-scheme: light;
      --bg1: #ffd0e5;
      --bg2: #ffe8f2;
      --accent: #bd1e59;
      --yes: #16a34a;
      --no: #ef4444;
      --heart: rgba(189, 30, 89, 0.22);
      --card: #ffffff;
      --shadow: 0 20px 60px rgba(189, 30, 89, 0.18);
      --radius: 16px;
      --transition-fast: 0.15s;
      --transition-normal: 0.25s;
      --transition-slow: 0.6s;
      --easing: cubic-bezier(0.4, 0, 0.2, 1);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      font-display: swap;
    }

    body {
      background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 36%, #fff 100%);
      background-size: 100% 140%;
      animation: gradientShift 14s ease-in-out infinite;
      color: #2b0f1b;
    }

    .gradient-background {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
    }

    .card {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 24px 28px;
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      max-width: 520px;
      width: 100%;
      animation: popIn var(--transition-slow) var(--easing) both;
      transition: transform var(--transition-fast) var(--easing), box-shadow var(--transition-fast) var(--easing);
      contain: layout style paint;
      will-change: transform;
      position: relative;
      z-index: 1;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 24px 70px rgba(189, 30, 89, 0.22);
    }

    .hearts {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
      content-visibility: auto;
      contain-intrinsic-size: 100vw 100vh;
    }

    .heart {
      position: absolute;
      width: 14px;
      height: 14px;
      background: var(--heart);
      transform: rotate(45deg);
      animation: floatUp 12s linear infinite;
      opacity: 0.8;
      animation-play-state: running;
    }

    .hearts.paused .heart {
      animation-play-state: paused;
    }

    .heart::before,
    .heart::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      background: var(--heart);
      border-radius: 50%;
    }

    .heart::before {
      left: -7px;
    }

    .heart::after {
      top: -7px;
    }

    img {
      border-radius: 12px;
      height: auto;
      max-width: 100%;
      aspect-ratio: 1 / 1;
      object-fit: cover;
      display: block;
      transition: opacity var(--transition-normal) var(--easing);
      contain: layout style paint;
      content-visibility: auto;
    }

    h1 {
      font-size: clamp(1.6rem, 2.2vw, 2.2rem);
      color: var(--accent);
      margin: 8px 0 0;
      font-weight: 700;
      font-style: italic;
      text-align: center;
      letter-spacing: 0.2px;
    }

    .subtext {
      margin: 0;
      color: #8a3a56;
      font-size: 0.98rem;
      text-align: center;
    }

    .hint {
      margin: 0;
      color: #9b5a73;
      font-size: 0.82rem;
      text-align: center;
    }

    .buttons {
      display: flex;
      gap: 12px;
      padding-top: 8px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }

    .actions {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      padding-top: 6px;
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 12px 22px;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
      transition: transform var(--transition-fast) var(--easing), 
                  box-shadow var(--transition-fast) var(--easing),
                  width var(--transition-normal) var(--easing),
                  height var(--transition-normal) var(--easing),
                  font-size var(--transition-normal) var(--easing);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      touch-action: manipulation;
      will-change: transform;
    }

    #yesButton { min-width: 120px; min-height: 44px; }

    button:focus-visible {
      outline: 3px solid rgba(189, 30, 89, 0.5);
      outline-offset: 3px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12), 0 0 0 3px rgba(189, 30, 89, 0.2);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px) scale(1.02);
    }

    button:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
    }

    button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    #yesButton {
      background: var(--yes);
    }

    #noButton {
      background: var(--no);
    }

    #resetButton {
      background: #f472b6;
      font-size: 16px;
      padding: 10px 18px;
    }

    .bounce {
      animation: bounce 2s ease infinite;
    }

    @keyframes bounce {
      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-20px);
      }
      60% {
        transform: translateY(-10px);
      }
    }

    @keyframes popIn {
      0% { transform: translateY(10px) scale(0.98); opacity: 0; }
      100% { transform: translateY(0) scale(1); opacity: 1; }
    }

    @keyframes floatUp {
      0% { transform: translateY(20vh) rotate(45deg) scale(0.9); opacity: 0; }
      10% { opacity: 0.85; }
      100% { transform: translateY(-120vh) rotate(45deg) scale(1.1); opacity: 0; }
    }

    @keyframes shake {
      0% { transform: translate3d(0, 0, 0); }
      20% { transform: translate3d(-6px, 0, 0); }
      40% { transform: translate3d(6px, 0, 0); }
      60% { transform: translate3d(-4px, 0, 0); }
      80% { transform: translate3d(4px, 0, 0); }
      100% { transform: translate3d(0, 0, 0); }
    }

    .shake {
      animation: shake 0.3s ease;
    }

    .swipe-feedback {
      animation: pulse 0.3s ease;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    @keyframes gradientShift {
      0% { background-position: 50% 0%; }
      50% { background-position: 50% 100%; }
      100% { background-position: 50% 0%; }
    }

    @media (max-width: 420px) {
      .buttons {
        flex-direction: column;
        width: 100%;
      }

      button {
        width: 100%;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }

      .bounce {
        animation: none;
      }

      .card {
        animation: none;
      }

      .heart {
        animation: none;
        opacity: 0.25;
      }

      button {
        transition: none;
      }

      body {
        animation: none;
      }
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg1: #2a0f1e;
        --bg2: #160a12;
        --accent: #ff7fb0;
        --heart: rgba(255, 127, 176, 0.35);
        --card: rgba(29, 18, 24, 0.95);
        --shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        --yes: #22c55e; --no: #f87171;
      }

      body {
        color: #f6dbe6;
      }

      .subtext {
        color: #d9a6ba;
      }

      .card {
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
    }

    .visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 1px, 1px); white-space: nowrap; border: 0; }
  </style>
</head>
<body class="gradient-background">
  <div class="hearts" aria-hidden="true">
    <span class="heart" style="left: 8%; animation-delay: 0s;"></span>
    <span class="heart" style="left: 18%; animation-delay: 2s; animation-duration: 14s;"></span>
    <span class="heart" style="left: 32%; animation-delay: 4s; animation-duration: 12s;"></span>
    <span class="heart" style="left: 46%; animation-delay: 1s; animation-duration: 16s;"></span>
    <span class="heart" style="left: 58%; animation-delay: 3s; animation-duration: 13s;"></span>
    <span class="heart" style="left: 70%; animation-delay: 6s; animation-duration: 15s;"></span>
    <span class="heart" style="left: 82%; animation-delay: 5s; animation-duration: 11s;"></span>
    <span class="heart" style="left: 92%; animation-delay: 7s; animation-duration: 17s;"></span>
  </div>
  <main class="card" aria-labelledby="valentineQuestion" id="card">
    <div id="status" role="status" aria-live="polite" class="visually-hidden"></div>
    <img id="imageDisplay" src="images/giphy.gif" alt="Niedliche animierte Grafik zum Valentinstag" width="300" height="300" loading="eager" decoding="async" fetchpriority="high" />
    <h1 id="valentineQuestion">Willst du meine Freundin sein?</h1>
    <p class="subtext" id="subtext">Ein kleines Ja macht meinen Tag perfekt.</p>
    <p class="hint" id="hint">Tipp: Mit Y/N geht's noch schneller. <span aria-hidden="true">Oder wische nach rechts/links!</span></p>
    <div class="buttons" id="responseButtons" role="group" aria-label="Antwortoptionen">
      <button id="yesButton" class="bounce" aria-label="Ja" type="button">Ja</button>
      <button id="noButton" aria-label="Nein" type="button">Nein</button>
    </div>
    <div class="actions" id="afterActions" hidden>
      <button id="resetButton" type="button" aria-label="Von vorne beginnen">Nochmal ðŸ”„</button>
    </div>
  </main>
  <noscript>Bitte aktiviere JavaScript, damit die Interaktionen funktionieren.</noscript>

  <script>
    // Configuration constants
    const CONFIG = {
      BUTTON_GROW_WIDTH: 20,
      BUTTON_GROW_HEIGHT: 20,
      FONT_SIZE_INCREASE: 6,
      MAX_BUTTON_WIDTH_FACTOR: 0.8,
      MAX_BUTTON_HEIGHT: 200,
      MAX_FONT_SIZE: 40,
      CONFETTI_TIMEOUT: 5000,
      PRELOAD_TIMEOUT: 2000,
      PRELOAD_FALLBACK: 100,
      CONFETTI_DELAYS: [0, 250, 550],
      STORAGE_KEY: 'valentineState',
      HAPTIC_LIGHT: 10,
      HAPTIC_MEDIUM: 20,
      HAPTIC_HEAVY: 50,
      SWIPE_THRESHOLD: 50
    };

    // Haptic Feedback
    const hapticFeedback = (intensity = CONFIG.HAPTIC_LIGHT) => {
      if ('vibrate' in navigator) {
        navigator.vibrate(intensity);
      }
    };

    // Performance monitoring
    const logPerformance = () => {
      if ('performance' in window && 'getEntriesByType' in performance) {
        try {
          const perfData = performance.getEntriesByType('navigation')[0];
          if (perfData) {
            console.log('Load time:', Math.round(perfData.loadEventEnd - perfData.fetchStart), 'ms');
          }
        } catch (e) {
          // Ignore errors
        }
      }
    };

    // Connection-aware loading
    const shouldPreload = () => {
      if ('connection' in navigator) {
        const conn = navigator.connection;
        if (conn.saveData) return false;
        if (conn.effectiveType === 'slow-2g' || conn.effectiveType === '2g') return false;
      }
      return true;
    };

    // State management
    const saveState = () => {
      try {
        const state = { noClickCount, buttonWidth, buttonHeight, fontSize, timestamp: Date.now() };
        sessionStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Failed to save state:', e);
      }
    };

    const loadState = () => {
      try {
        const saved = sessionStorage.getItem(CONFIG.STORAGE_KEY);
        if (saved) {
          const state = JSON.parse(saved);
          const age = Date.now() - (state.timestamp || 0);
          if (age < 3600000) return state;
        }
      } catch (e) {
        console.warn('Failed to load state:', e);
      }
      return null;
    };

    const clearState = () => {
      try {
        sessionStorage.removeItem(CONFIG.STORAGE_KEY);
      } catch (e) {
        console.warn('Failed to clear state:', e);
      }
    };

    // Error boundary
    const showError = (message) => {
      const statusEl = document.getElementById('status');
      if (statusEl) {
        statusEl.textContent = message;
        statusEl.style.position = 'relative';
        statusEl.style.color = '#ef4444';
        setTimeout(() => {
          statusEl.textContent = '';
          statusEl.style.position = 'absolute';
        }, 3000);
      }
    };

    window.addEventListener('error', (event) => {
      console.error('Global error:', event.error);
      showError('Ein Fehler ist aufgetreten. Bitte Seite neu laden.');
    });

    window.addEventListener('unhandledrejection', (event) => {
      console.error('Unhandled promise rejection:', event.reason);
    });

    // Cleanup listeners array
    const listeners = [];
    const addListener = (element, event, handler, options) => {
      element.addEventListener(event, handler, options);
      listeners.push({ element, event, handler, options });
    };

    const cleanup = () => {
      listeners.forEach(({ element, event, handler, options }) => {
        element.removeEventListener(event, handler, options);
      });
      listeners.length = 0;
    };

    const getById = (id) => document.getElementById(id);

    const imagePaths = [
      "images/giphy.gif",
      "images/image2.gif",
      "images/image3.gif",
      "images/image4.gif",
      "images/image5.gif",
      "images/image6.gif",
      "images/image7.gif"
    ];

    const imageAlts = [
      "Willst du meine Freundin sein ? Frage an die wichtigste Person in meinem Leben",
      "SÃ¼ÃŸe Reaktion 1",
      "SÃ¼ÃŸe Reaktion 2",
      "SÃ¼ÃŸe Reaktion 3",
      "SÃ¼ÃŸe Reaktion 4",
      "SÃ¼ÃŸe Reaktion 5",
      "SÃ¼ÃŸe Reaktion 6"
    ];

    const noTexts = [
      "Nein",
      "Bist du dir sicher?",
      "Ganz sicher?",
      "Wirklich ganz ganz sicher?:(",
      "Immernoch nicht?",
      "Warum nicht :("
    ];

    const finalIndex = imagePaths.length - 1;
    const maxNoClicks = Math.min(noTexts.length - 1, finalIndex);
    let confettiLoading = null;
    let noClickCount = 0;
    let buttonWidth = 0;
    let buttonHeight = 0;
    let fontSize = 0;
    let didPreload = false;
    let didFallback = false;
    let statusEl = null;

    const setImage = (imageDisplay, src, alt) => {
      const currentSrc = imageDisplay.src.split('?')[0];
      const newSrc = src.includes('://') ? src.split('?')[0] : new URL(src, window.location.href).href.split('?')[0];
      
      if (currentSrc === newSrc) return;
      
      imageDisplay.style.opacity = "0";
      if (alt) {
        imageDisplay.alt = alt;
      }
      
      const onLoad = () => {
        requestAnimationFrame(() => {
          imageDisplay.style.opacity = "1";
        });
      };
      
      imageDisplay.addEventListener("load", onLoad, { once: true });
      imageDisplay.src = src;
      
      if (imageDisplay.complete && imageDisplay.naturalHeight !== 0) {
        onLoad();
      }
    };

    const updateYesButton = (yesButton) => {
      const maxSize = Math.min(window.innerWidth * CONFIG.MAX_BUTTON_WIDTH_FACTOR, 420);
      const clampedWidth = Math.min(buttonWidth, maxSize);
      const clampedHeight = Math.min(buttonHeight, CONFIG.MAX_BUTTON_HEIGHT);
      const clampedFont = Math.min(fontSize, CONFIG.MAX_FONT_SIZE);
      yesButton.style.width = `${clampedWidth}px`;
      yesButton.style.height = `${clampedHeight}px`;
      yesButton.style.fontSize = `${clampedFont}px`;
    };

    const loadConfetti = () => {
      if (typeof confetti === "function") {
        return Promise.resolve();
      }
      if (confettiLoading) {
        return confettiLoading;
      }
      confettiLoading = new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = "libs/confetti.min.js";
        script.defer = true;
        const timer = setTimeout(() => {
          console.warn("Confetti loading timeout");
          resolve();
        }, CONFIG.CONFETTI_TIMEOUT);
        script.onload = () => { 
          clearTimeout(timer); 
          resolve(); 
        };
        script.onerror = (e) => { 
          clearTimeout(timer); 
          console.error("Confetti loading failed:", e);
          resolve(); 
        };
        document.head.appendChild(script);
      });
      return confettiLoading;
    };

    const handleNo = (yesButton, noButton, imageDisplay, card) => {
      if (noClickCount >= maxNoClicks) {
        return;
      }
      hapticFeedback(CONFIG.HAPTIC_MEDIUM);
      noClickCount += 1;
      setImage(imageDisplay, imagePaths[noClickCount], imageAlts[noClickCount] || imageAlts[0]);
      if (card) {
        card.classList.remove("shake");
        void card.offsetWidth;
        card.classList.add("shake");
      }
      buttonWidth += CONFIG.BUTTON_GROW_WIDTH;
      buttonHeight += CONFIG.BUTTON_GROW_HEIGHT;
      fontSize += CONFIG.FONT_SIZE_INCREASE;
      updateYesButton(yesButton);
      noButton.textContent = noTexts[noClickCount];
      saveState();
      if (statusEl) { statusEl.textContent = `Du hast "${noButton.textContent}" gewÃ¤hlt.`; }
      if (noClickCount >= maxNoClicks) {
        noButton.disabled = true;
        noButton.setAttribute("aria-disabled", "true");
        if (statusEl) { statusEl.textContent = "Okay, ich frage nicht mehr."; }
      }
      const nextIndex = Math.min(noClickCount + 1, finalIndex);
      if (nextIndex > noClickCount) {
        const img = new Image();
        img.src = imagePaths[nextIndex];
      }
    };

    const handleYes = (valentineQuestion, responseButtons, imageDisplay, subtext, hint, afterActions) => {
      hapticFeedback(CONFIG.HAPTIC_HEAVY);
      setImage(imageDisplay, imagePaths[finalIndex], "Jubelndes GIF â€“ Danke fÃ¼r dein Ja!");
      valentineQuestion.textContent = "Yayyy!! :3";
      valentineQuestion.setAttribute("tabindex", "-1");
      valentineQuestion.focus({ preventScroll: true });
      if (subtext) { subtext.textContent = "Du hast mir ein LÃ¤cheln geschenkt."; }
      if (hint) { hint.style.display = "none"; }
      if (statusEl) { statusEl.textContent = "Danke fÃ¼r dein Ja!"; }
      responseButtons.style.display = "none";
      if (afterActions) { afterActions.hidden = false; }
      clearState();
      if (!window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
        loadConfetti().then(() => {
          if (typeof confetti === "function") {
            const fireConfetti = () => {
              confetti({
                particleCount: 100,
                spread: 70,
                origin: { y: 0.6 }
              });
            };
            CONFIG.CONFETTI_DELAYS.forEach((delay) => {
              setTimeout(fireConfetti, delay);
            });
          }
        }).catch((err) => {
          console.error("Confetti error:", err);
        });
      }
    };

    const preloadOnFirstInteraction = () => {
      if (didPreload || !shouldPreload()) {
        return;
      }
      didPreload = true;
      const loadImages = () => {
        for (let i = 1; i < imagePaths.length; i += 1) {
          const img = new Image();
          img.src = imagePaths[i];
        }
      };
      if ("requestIdleCallback" in window) {
        requestIdleCallback(loadImages, { timeout: CONFIG.PRELOAD_TIMEOUT });
      } else {
        setTimeout(loadImages, CONFIG.PRELOAD_FALLBACK);
      }
    };

    window.addEventListener("DOMContentLoaded", () => {
      const yesButton = getById("yesButton");
      const noButton = getById("noButton");
      const valentineQuestion = getById("valentineQuestion");
      const responseButtons = getById("responseButtons");
      const imageDisplay = getById("imageDisplay");
      const subtext = getById("subtext");
      const hint = getById("hint");
      const afterActions = getById("afterActions");
      const resetButton = getById("resetButton");
      const card = getById("card");
      statusEl = getById("status");

      if (!yesButton || !noButton || !valentineQuestion || !responseButtons || !imageDisplay) {
        console.error("Required elements not found");
        return;
      }

      // Load saved state
      const savedState = loadState();
      if (savedState) {
        noClickCount = savedState.noClickCount || 0;
        buttonWidth = savedState.buttonWidth || yesButton.offsetWidth || 120;
        buttonHeight = savedState.buttonHeight || yesButton.offsetHeight || 44;
        fontSize = savedState.fontSize || parseFloat(getComputedStyle(yesButton).fontSize) || 20;
        if (noClickCount > 0) {
          setImage(imageDisplay, imagePaths[noClickCount], imageAlts[noClickCount]);
          updateYesButton(yesButton);
          noButton.textContent = noTexts[noClickCount];
          if (noClickCount >= maxNoClicks) {
            noButton.disabled = true;
            noButton.setAttribute("aria-disabled", "true");
          }
        }
      } else {
        buttonWidth = yesButton.offsetWidth || 120;
        buttonHeight = yesButton.offsetHeight || 44;
        fontSize = parseFloat(getComputedStyle(yesButton).fontSize) || 20;
      }
      imageDisplay.style.opacity = "1";

      // Intersection Observer for hearts animation
      const heartsContainer = document.querySelector('.hearts');
      if (heartsContainer && 'IntersectionObserver' in window && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        const heartsObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            heartsContainer.classList.toggle('paused', !entry.isIntersecting);
          });
        }, { threshold: 0.1 });
        heartsObserver.observe(heartsContainer);
      }

      const firstNext = new Image();
      firstNext.src = imagePaths[1];

      imageDisplay.addEventListener("error", () => {
        if (didFallback) return;
        didFallback = true;
        setImage(imageDisplay, imagePaths[finalIndex], "Fallback-Bild");
      });

      addListener(noButton, "click", () => handleNo(yesButton, noButton, imageDisplay, card));
      addListener(yesButton, "click", () => handleYes(valentineQuestion, responseButtons, imageDisplay, subtext, hint, afterActions));
      if (resetButton) {
        addListener(resetButton, "click", () => {
          clearState();
          cleanup();
          window.location.reload();
        });
      }
      const events = ["pointerdown", "touchstart", "mousedown"];
      events.forEach((eventType) => {
        addListener(document, eventType, preloadOnFirstInteraction, { once: true, passive: true });
      });
      
      let lastKeyTime = 0;
      const KEY_DEBOUNCE = 200;
      
      addListener(document, "keydown", (event) => {
        if (responseButtons.style.display === "none") {
          return;
        }
        
        const now = Date.now();
        if (now - lastKeyTime < KEY_DEBOUNCE) {
          return;
        }
        
        const key = event.key.toLowerCase();
        if (key === "y" || key === "j") {
          event.preventDefault();
          lastKeyTime = now;
          yesButton.click();
        } else if (key === "n") {
          event.preventDefault();
          lastKeyTime = now;
          noButton.click();
        }
      }, { passive: false });

      // Page Visibility API - pause animations when tab is hidden
      addListener(document, 'visibilitychange', () => {
        const hearts = document.querySelector('.hearts');
        if (document.hidden && hearts) {
          hearts.classList.add('paused');
        } else if (hearts && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          hearts.classList.remove('paused');
        }
      });

      // Cleanup on page unload
      addListener(window, 'beforeunload', () => {
        cleanup();
      });

      // Touch gestures for mobile
      let touchStartX = 0;
      let touchStartY = 0;
      
      addListener(card, 'touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, { passive: true });
      
      addListener(card, 'touchend', (e) => {
        if (responseButtons.style.display === 'none') return;
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Swipe right for Yes, left for No
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > CONFIG.SWIPE_THRESHOLD) {
          hapticFeedback(CONFIG.HAPTIC_LIGHT);
          card.classList.add('swipe-feedback');
          setTimeout(() => card.classList.remove('swipe-feedback'), 300);
          
          if (deltaX > 0) {
            yesButton.click();
          } else {
            noButton.click();
          }
        }
      }, { passive: true });

      // Log performance metrics
      if (document.readyState === 'complete') {
        logPerformance();
      } else {
        addListener(window, 'load', logPerformance);
      }
    });
  </script>
</body>
</html>
